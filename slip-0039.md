# SLIP-0039 : Shamir's Secret-Sharing for Mnemonic Codes

```
Number:  SLIP-0039
Title:   Shamir's Secret-Sharing for Mnemonic Codes
Type:    Standard
Status:  Draft
Authors: Pavol Rusnak <stick@satoshilabs.com>
         Ondrej Vejpustek <ondrej.vejpustek@satoshilabs.com>
         Tomas Susanka <tomas.susanka@satoshilabs.com>
         Marek Palatinus <slush@satoshilabs.com>
         Jochen Hoenicke <hoenicke@gmail.com>
Created: 2017-12-18
```

## Abstract

This SLIP describes a standard and interoperable implementation of Shamir's secret-sharing (SSS). SSS divides a secret into unique parts which can be distributed among participants, and requires a specified minimum number of parts be supplied in order to reconstruct the original secret. Knowledge of fewer than the required number of parts does not leak information about the secret.

## Motivation

Preservation of digital assets is generally important and it is especially important in the case of decentralized payments systems such as Bitcoin, where there is no recourse in the case of loss of an asset. The usual approach to protecting digital assets is redundant backups, but when the asset itself is of significant and liquidable value, there is a substantial risk of the backup holder absconding with the asset. Shamir's secret-sharing provides a better mechanism for replicating secrets, by distributing custodianship among a number of trusted parties in a manner that can prevent loss even if one or a few of those parties become compromised.

However, the lack of SSS standardization to date presents a risk of being unable to perform secret recovery in the future should the tooling change. Therefore, we propose standardizing SSS so that SLIP-0039 compatible implementations will be interoperable.

## Shamir's secret-sharing

Shamir's secret-sharing (SSS) is a cryptographic mechanism describing how to divide a secret into `N` unique parts, where any `T` of them are required to reconstruct the secret. First, a polynomial `f` of degree `N-1` is constructed and each party is given a corresponding point - a non-zero integer `x` input to the polynomial and the corresponding output `f(x)`.

When sufficient `T` values are provided the points exactly define the polynomial. The polynomial's value of `f(0) = S` corresponds to the pre-master secret. More detail on SSS can be found on [Wikipedia](https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing).

![curve](slip-0039/curve.png)

## Generating the mnemonic shares

The value to be encoded as the master secret must be a multiple of 16 bits. This is typically a master seed for a hierarchical deterministic wallet, but may be another secret value which was chosen from its key space randomly with a uniform distribution. The master secret is first encrypted to a pre-master secret using a passphrase. The pre-master secret is divided into `N` Shamir parts and `T` specifies how many of those parts are needed to reconstruct the pre-master secret. We use `GF(256)` reduced by `x^8 + x^4 + x^3 + x + 1` (the Rijndael polynomial) as the underlying finite field<sup>[2](#FiniteField)</sup>.

We propose the following format of the shares:

| identifier (id) | threshold (T-1) | index (I) | share (s<sub>I</sub>) | checksum (C) |
|-----------------|-----------------|-----------|-----------------------|--------------|
| 20 bits         | 6 bits          | 6 bits    | 8n bits               | 30 bits      |

* identifier (`id`) field is a random 20-bit value which is the same for all shares and used to detect whether the shares belong together; it's also used as salt in key derivation functions.
* threshold (`T`) field indicates how many shares are needed to reconstruct the secret the actual value is encoded as `T-1`, so a value of 0 indicates that a single share is needed (`T=1`), a value of 1 indicates that two shares are needed (`T=2`) etc.
* index (`I`) field corresponds to the SSS part's `x` value, `x=I+1`, (see the diagram above).
* share (s<sub>I</sub>) field is the corresponding SSS part's `f(x)` values (see the diagram above), right-padded with "0" bits so that the length of the padded share in bits becomes a multiple of ten. In all, at most eight bits are appended.
* checksum (`C`) field is a Bech32 checksum (defined in BIP-0173) of the whole share (that is `id || T || I || s`); the human-readable part (hrp) of Bech32 is "slip0039"

This structure is then converted into a mnemonic code by splitting it up into 10 bit segments with each becoming an index to a word list containing exactly 1024 words (see below).

| share length | total length           | security |
|--------------|------------------------|----------|
| 130 bits     | 190 bits = 19 words    | 128 bits |
| 260 bits     | 320 bits = 32 words    | 256 bits |

This construction yields a beneficial property where the identifier transforms into exactly the first two words of the mnemonic code, so the user can immediately tell whether the correct shares are being combined (i.e. they have to have the same first two words). Moreover, the third word encodes exactly the index/threshold values, so for example share #2 of 3 required shares will always correspond to the same word.

## Converting the mnemonic shares to the pre-master secret

First, we check the checksum of each share and abort if they don't match. Implementations SHOULD NOT implement correction beyond potentially suggesting to the user where in the string an error might be found, without suggesting the correction to make.

If the checksum of each share is correct and a sufficient number of shares *k* have been provided, *k*&ge;*T*, the pre-master secret can be computed using Lagrange interpolation:

## Passphrase

To allow additional protection of the master secret using a passphrase, a strong pseudorandom permutation<sup>[3](#StrongPRP)</sup> is used. If no passphrase is provided an empty string should be used as the passphrase.

A passphrase should contain only printable ASCII characters (codepoints 32-126) to achieve the best interoperability among various operating systems and wallet implementations.

The strong pseudorandom permutation uses the Luby-Rackoff construction which consists of a four round Feistel network with PBKDF2 as the round function. The pre-master secret is first split into two equally long parts. `L_0` is the first n/2 octets of the pre-master secret and `R_0` is the last n/2 octets of the pre-master secret.
```
for i = 0, 1, 2, 3:
	L_{i+1} = R_i
	R_{i+1} = L_i xor F(R_i)
```
The master secret is then `R_4 || L_4`.

The round function `F(R_i)` is defined as follows:
```
F(R_i) = PBKDF2(PRF = HMAC-SHA256, Password = (passphrase || i), Salt = ("slip0039" || id || T || R_i), iterations = 5000, dkLen = n/2 octets)
```
The random identifier value `id` is encoded as two lowercase words from the wordlist separated by exactly one space (codepoint 32).

The master secret can be used as the master seed `S` for Hierarchical Deterministic Wallets described in BIP-0032.

## Versioning

Our scheme doesn't support versioning. This is intentional to avoid unclear claims such as SLIP-0039 compatibility without a clear understanding of which version of the scheme is actually meant.

## Localization

No localization is supported. This standard deals with a set of English words only. Previous attempts with arbitrary wordlists caused lots of confusion among users and decreased interoperability across various implementations.

## Wordlist

The wordlist mandated by this SLIP is [available here](slip-0039/wordlist.txt). Several criteria were applied in creation of the list:

* The wordlist is alphabetically sorted.
* No word is shorter than 4 letters.
* No word is longer than 8 letters.
* All words begin with a unique 4-letter prefix.
* The wordlist contains only common English words (+ the word "satoshi").
* The minimum Damerau-Levenshtein distance between any two words is at least 2.
* The similarity between the pronunciation of any two words has been minimised.

(see the [test](slip-0039/test_wordlist.sh) which checks whether these criteria are fulfilled).

## Test Vectors

TBD

## Design Rationale

### <a name="IndexEncoding"></a>Index encoding

It is anticipated that 64 shares will be more than enough for any application of Shamir's Secret Sharing Scheme to BIP-32 master seeds. Thus to reduce the mnemonic length, the Index and Threshold values are restricted to 6 bits each.

### <a name="FiniteField"></a>Choice of finite field

Finite fields of the form GF(2<sup>*n*</sup>) and GF(*p*), where *p* is a prime number, were considered for this scheme. The field GF(256) was chosen, because the field arithmetic is easy to implement in any programming language and many implementations are already available since it is used in the AES cipher. The fact that it is byte oriented makes it easy to work with.

Using a field of prime order GF(*p*), where log<sub>2</sub> *p* is approximately the length of the secret in bits, would require support for multi-precision arithmetic. Many programming languages, such as C/C++, do not support multi-precision arithmetic out of the box. Implementations would also need to store information about the prime number that should be used for each admissible length of the secret or they would need to compute the prime number on the fly.

Choosing GF(2<sup>*n*</sup>), where *n* is the length of the secret in bits would require a more complicated implementation than GF(256). This is in part due to the multi-precision nature of the arithmetic and in part due to the fact that implementations would need to store the lexicographically minimal irreducible polynomial of degree *n* for each admissible value of *n* or they would need to be able to compute this polynomial on the fly.

### <a name="StrongPRP"></a>Strong pseudorandom permutation

The reason why a strong pseudorandom permutation was chosen to protect the master secret is to thwart attacks where the adversary obtains, for example, the first several octets of `T` different shares. If the master secret were not protected by a pseudorandom permutation, the adversary could compute a part of the master secret. This is a serious concern if the master secret is for example a private key. Passphrase protection using AES in any of the common block cipher modes suffers from the same problem.

The role of the key derivation function in the scheme is twofold. Firstly, it protects the passphrase against brute-force and dictionary attacks. Secondly, if the adversary obtains a part of the pre-master secret as described above, the key derivation function protects against brute-force attacks which attempt to reveal the unknown part of the pre-master secret.

### <a name="KDFParam"></a>Choice of KDF function and parameters

PBKDF2 is a widely used standard password-based key derivation function. Newer key derivation functions such as scrypt or Argon2 were considered, but these require a large amount of memory, which is a limiting factor in hardware wallets.

The number of iterations in PBKDF2 was chosen to be 5000. Since this PBKDF2 is called four times, there is a total of 20000 iterations. A larger number of iterations in PBKDF2 would impact the user experience in hardware wallets.

### <a name="PassphraseVerification"></a>Passphrase verification

The proposed design does not provide a way to verify that the correct passphrase was used to decrypt the master secret. This is an intentional feature which allows the user to derive multiple master secrets from a single pre-master secret by using different passphrases. This design allows for plausible deniability when the master secret is used as the master seed for a hierarchical deterministic wallet (see BIP-32). Every passphrase generates a valid seed but only the correct one will make the desired wallet available. Thus the owner can use one passphrase to access their real wallet and another passphrase to access a decoy wallet. If the owner is later coerced into revealing their passphrase either by [law](https://en.wikipedia.org/wiki/Key_disclosure_law) or by force, then they can reveal the passphrase which accesses the decoy wallet and [plausibly deny](https://en.wikipedia.org/wiki/Plausible_deniability) the existence of their real wallet, because there is no way for the coercer to prove that the decoy wallet is not the real one.

## References

* [BIP-0032: Hierarchical Deterministic Wallets](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
* [Secret Sharing Step by Step by Point Software](http://www.pointsoftware.ch/en/secret-sharing-step-by-step/)
* [BIP-0173: Base32 address format for native v0-16 witness outputs](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#Bech32)
